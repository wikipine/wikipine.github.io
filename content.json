{"meta":{"title":"熊猫园","subtitle":"博客","description":"闲时杂谈","author":"wikipine","url":"http://yoursite.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-04-25T12:34:50.458Z","updated":"2019-04-25T12:34:50.444Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":"&lt;!DOCTYPE html&gt; 404"},{"title":"关于","date":"2019-04-25T13:04:44.000Z","updated":"2019-04-25T13:28:27.069Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"首先感谢各位看客老爷们百忙之中能看到这个页面 我本人93射手男，其他个人信息就不公布了 欢迎技术交流，或愿意交朋友的点击 社交 里面的QQ (暗号：github) 博客本博客不定时更新 主要记录个人的学习心得，以及工作中遇到的值得记录的问题，内容非研究级别，但尽量实用型。 有何不对的地方欢迎指正。"}],"posts":[{"title":"Yapi启动&重启","slug":"linux/yapi-restart","date":"2019-07-22T02:37:00.000Z","updated":"2019-07-22T02:38:17.592Z","comments":true,"path":"2019/07/22/linux/yapi-restart/","link":"","permalink":"http://yoursite.com/2019/07/22/linux/yapi-restart/","excerpt":"","text":"题记这篇文章不算从零搭建，只是记录一下其中的坑。 环境客户端：Chrome服务器：Linux + Nginx 正文Yapi的内网搭建，照官网上来的即可，99.99%不会出问题（0.01%看人品）。 在公司搭建的过程中，运维搭建好，配好域名，在使用过程中发现，在添加，删除，编辑，会出现奇怪的问题，要么JS报错导致页面错误，要么页面没变化，刚开始真的没头绪。 这时候，万能的 F12 来了。 看到一个很奇怪的现象 from disk cache 字面意思读本地缓存，这就神奇了，这之前没遇到过，点开发现 竟然存在10分钟的缓存， 比较了我本地搭建的，IP+端口没有缓存的，本地的操作就都是正常的。 至此大胆猜测了一下，就是这缓存导致的，而且假设有缓存的情况，上述的奇怪的现象都能解释得通了。 于是让运维去检查一下nginx里面是不是设置了缓存到期时间。 果然，然后，就好了。 结束语其实在之前，运维搭过一次，但是之前在忙别的事，竟然让运维重新搭建，主要自己本地的是好的，然后也是自己不熟nodejs，有点惶恐。 这次问题的解决，发现问题可以慢慢仔细分析，总能解决的。","categories":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/categories/运维/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"},{"name":"yapi","slug":"yapi","permalink":"http://yoursite.com/tags/yapi/"}],"keywords":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/categories/运维/"}]},{"title":"PHP 之 跨域处理","slug":"php/cross-domain","date":"2019-06-11T06:24:00.000Z","updated":"2019-06-12T07:12:53.375Z","comments":true,"path":"2019/06/11/php/cross-domain/","link":"","permalink":"http://yoursite.com/2019/06/11/php/cross-domain/","excerpt":"","text":"题记跨域的问题，老生常谈，在前后端分离的项目中非常常见，主要是浏览器的同源策略导致的，解决的方案也非常成熟。这里记录一下自己的处理心得吧。 什么是同源策略？同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。 更多解释 PHP 中的处理上面的同源策略中，提到了授权，授权就是同意。Request Header中会携带源的信息，那么我只需要在Response中允许即可，这样子浏览器就能执行操作了。 PHP中的处理比较简单，以 TP5为例 创建一个中间件 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace app\\http\\middleware;use think\\Response;class CrossDomain&#123; // 允许访问的 handle const ALLOW_HEADERS = [ 'Authorization', 'Content-Type', 'If-Match', 'If-Modified-Since', 'If-None-Match', 'If-Unmodified-Since', 'X-Requested-With', 'Accept', 'X-token' ]; // 允许的域名 const ALLOW_ORIGIN = [ \"http://localhost:8080\" ]; public function handle($request, \\Closure $next) &#123; header('Access-Control-Allow-Origin: '.implode(',',self::ALLOW_ORIGIN)); header('Access-Control-Allow-Headers: '.implode(',',self::ALLOW_HEADERS)); header('Access-Control-Allow-Methods: GET, POST, PATCH, PUT, DELETE'); header('Access-Control-Max-Age: 86400'); if (strtoupper($request-&gt;method()) == \"OPTIONS\") &#123; header('status: 204'); return Response::create()-&gt;send(); &#125; return $next($request); &#125;&#125; 这样子所有的请求都会被处理到 核心就是 header 里面的 Access-Control-* 部分，基本上就是哪里不允许，就让哪里允许即可。 非中间件的处理，就是在你返回的时候，加上那部分 允许的 header 内容就行了。 细心人的会发现，有个判断 1234if (strtoupper($request-&gt;method()) == \"OPTIONS\") &#123; header('status: 204'); return Response::create()-&gt;send();&#125; 下面就讲一下什么是OPTIONS 什么是 OPTIONS？其实在跨域处理中，这个带OPTIONS的请求不一定会发的，但有时候会必定发送，如上传文件的时候，属于浏览器自动发送的请求。但之前在写前端的时候，不知道改了什么东西，导致每次发起不同的请求之前，浏览器必定会发起这个请求，但是又不返回内容。这样子可想而知，服务器每次都要处理一个无意义的请求，这样子绝对是不太好的。 上面说到跨域的授权，那么这个OPTIONS请求，可能就是允许访问的许可证，告诉浏览器，我允许你执行下面这个操作。 参考 HTTP访问控制（CORS） 上面的文章，针对这个项目做了非常详细的说明 归纳一下，如何要避免OPTIONS请求，需要满足简单请求即可 123456789101.请求方式只能是：GET、POST、HEAD2.HTTP请求头限制这几种字段（不得人为设置该集合之外的其他首部字段）：Accept、Accept-Language、Content-Language、Content-Type（需要注意额外的限制）、DPR、Downlink、Save-Data、Viewport-Width、Width3.Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain4.请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。5.请求中没有使用 ReadableStream 对象。 看了这个之后，再回想自己的项目，发现，多了个 X-token，那么这样我的请求就变成 非简单请求了，所以每次都要进行一次预校验处理。 END跨域中要想不出现OPTIONS,只做简单请求即可，基本上简单请求能满足大部分的业务需求了，如果不纠结这个，那就允许它在好了。 对了 关于上面的 204 是我之前看到一篇文章里的一句话 设置响应状态码为 204 是为了告知客户端表示该响应成功了，但是该响应并没有返回任何响应体，如果状态码为 200，还得携带多余的响应体，在这种场景下是完全多余的，只会浪费流量。 具体文章-&gt;OPTIONS 跨域请求","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}],"keywords":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}]},{"title":"Element 之 TreeTable Node 未刷新处理","slug":"vue/elm-table-tree","date":"2019-06-10T06:24:00.000Z","updated":"2019-06-12T06:22:48.107Z","comments":true,"path":"2019/06/10/vue/elm-table-tree/","link":"","permalink":"http://yoursite.com/2019/06/10/vue/elm-table-tree/","excerpt":"","text":"问题描述element tree table开启 lazy 后，修改Node下的内容，无法刷新处理思路本来以为是版本的问题，当前使用的是 2.9.1 ，降了版本后，发现不行，First Blood!!! 询问了钉钉Element群里的人，有遇到和我一样问题的人，没有结果，Double Kill!!! 最后想到了，那就重新刷新一下页面？ window.location.reload() this.$router.go(0) 手动刷新 页面刷新当然可以，但是，我们这个是单页面系统，重新刷新的话，资源的重新加载+基础页面的重新渲染，这个代价太大了！ vue这么强大的框架，肯定有解决方案的。 找了一下，果然 provide / inject 完美解决 核心思路： 在父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量 参考：vue刷新当前页面 END上述的方法暴力的解决了node 节点数据部分的问题，带来的影响就是体验上有点不太好，每次刷新，之前的展开的node都会没有了。 目前暂时没找到更好的处理的方法，可能没掌握Element正确的使用姿势吧。之后有更好的方案，再更新。 未完，待续…","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"element","slug":"element","permalink":"http://yoursite.com/tags/element/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"PHP之__autoload()","slug":"php/autoload","date":"2019-05-29T02:39:00.000Z","updated":"2019-05-29T03:03:21.078Z","comments":true,"path":"2019/05/29/php/autoload/","link":"","permalink":"http://yoursite.com/2019/05/29/php/autoload/","excerpt":"","text":"题记记录一下 __autoload的使用，平时在业务开发中，基本不会使用到，概念是清楚的。Composer,框架基本上都会用到。下面记录一下一个经典的使用案例 经典例子目录结构 MyClass.php 1234567&lt;?phpclass MyClass &#123; function printHelloWorld()&#123; print \"hello world\"; &#125;&#125; general.inc 12345&lt;?phpfunction __autoload($classname) &#123; require_once './classes/'.$classname.'.php';&#125; 入口文件 main.php 123456&lt;?phprequire_once 'general.inc';$obj = new MyClass();$obj-&gt;printHelloWorld(); 输出 hello world inc 后缀说明 inc 文件是include file的意思。实际上，文件的后缀对于文件包含是无所谓,你可以包含一个asp文件，也可以包含txt文。一般我们使用inc作为后缀，是因为这样能体现该文件的作用。另外, .inc文件的作用有点类似于C/C++内的.H .HPP头文件，使用inc文件可以使我们的程序，增加可读性","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}],"keywords":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}]},{"title":"Hexo 图片展示","slug":"hexo/hexo-image","date":"2019-05-09T13:36:00.000Z","updated":"2019-05-09T13:42:29.983Z","comments":true,"path":"2019/05/09/hexo/hexo-image/","link":"","permalink":"http://yoursite.com/2019/05/09/hexo/hexo-image/","excerpt":"","text":"题记本来是传到简书上做图库，不太道德，而且简书做了防盗链的处理，那流量就是从自己本地走好了。 转载 优化hexo目录，使本地图片能显示出来 修改配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git（未验证有什么用） 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](xxxx/图片名.jpg) END图片暂时也不算多，也不太喜欢传图，后期应该会把本博客的图片转到腾讯云的COS 上，免费空间挺大的。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"LNMP安装多版本PHP共存","slug":"linux/php-versions","date":"2019-05-08T06:24:00.000Z","updated":"2019-05-09T13:21:36.061Z","comments":true,"path":"2019/05/08/linux/php-versions/","link":"","permalink":"http://yoursite.com/2019/05/08/linux/php-versions/","excerpt":"","text":"题记对于一个项目来说，多版本的情况可能性很小，但对于开发者来说，不同的项目对应不同的版本，十分常见，机子资源有限，那么就只能多版本来运行了。 基于LNMP来安装之前的PHP 7.2 就是用这个全家桶来搞的，目前的手头上的项目需要7.1.18和5.3.29这两个版本，先用这个全家桶来安装一下7.1.18看看。 进入 lnmp 目录执行 1./install.sh mphp 选择想要的版本，Enter,喝杯咖啡，等待结果就行 弹指一挥间，自动安装完成 在 /usr/local 目录下，你会发现多了个 php7.1 检查一下是否已经启动 1ps aux | grep 'php-fpm' 看来自动启动好了 之后在nginx中的 fastcgi_pass 改成对应的 sock链接就行 查看这个可以在对应的 php-fpm.conf 中查看，如果是lnmp的话，不出意外是在tmp下的。 123456789location ~ \\.php$ &#123; fastcgi_pass unix:/tmp/php-cgi7.1.sock; # fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_split_path_info ^(.+\\.php)(.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; 这样不同的项目就能依据自己的需要去配置版本了。 自行编译安装任意版本其实lnmp提供的都是稳定版本的，基本上够用了，1.5直接从5.3.29-7.2.6，跨幅还是可以的，基本上够用。不过为了了解一下编译安装，并整合到里面，5.3.29的版本，我选择用 从官网下载，编译安装一下。 实现的结果要同 7.1.18，开机自启，加入服务。 此类教程网上更加详尽的有很多，但 纸上得来终觉浅,绝知此事要躬行 参看文章：Linux上编译安装PHP 下载对应的php版本 这里选择在线下载 1wget https://www.php.net/distributions/php-5.3.29.tar.gz （有点慢，建议换资源，不过暂时没找到，先忙点别的事情去了） 好吧，膝关节给跪了，3次节点错误，下到一半就挂了，果断换资源了。 1wget http://cn2.php.net/get/php-5.3.29.tar.gz/from/this/mirror 这样子下载下来的名字是mirror的 1wget -O php-5.3.29.tar.gz http://cn2.php.net/get/php-5.3.29.tar.gz/from/this/mirror 上述命令为重命名下载，wget更多的用法，可以自行搜索 1tar -zxf php-5.3.29.tar.gz 解压后进入安装目录，开始三部曲 configure make make install 123456789101112131415161718192021222324252627282930313233./configure \\--prefix=/usr/local/php5.3.29 \\--with-config-file-path=/usr/local/php5.3.29/etc \\--disable-fileinfo \\--with-pdo-mysql=/usr/local/mysql \\--with-iconv=/usr/local/lib/libiconv \\--with-mcrypt \\--with-bz2 \\--with-gd \\--with-freetype-dir \\--with-jpeg-dir \\--with-png-dir \\--with-zlib-dir \\--with-libxml-dir \\--with-curl \\--with-pear \\--with-openssl \\--with-fpm-group=www \\--with-fpm-user=www \\--enable-fpm \\--enable-xml \\--enable-bcmath \\--enable-shmop \\--enable-sysvsem \\--enable-inline-optimization \\--enable-mbregex \\--enable-mbstring \\--enable-gd-native-ttf \\--enable-pcntl \\--enable-sockets \\--enable-soap \\--enable-session \\--enable-zip 上面的配置 1--with-iconv=/usr/local/lib/libiconv 这是我后加的，系统中之前已经安装过，所以直接引进来。之前没有的话，configure 过程中会报错，不过也可以选择不安装这个扩展。iconv这个扩展可以不用的。 （更多处理方案） 原则上一般这个过程报错，解决方案就是安装这些依赖 之后 make &amp;&amp; make install ,一气呵成。 HP安装完成，进行配置，进入/usr/local/php5.3.29/etc 中，发现没有php.ini文件，这时应该将安装包目录 /tmp/php-5.3.29 下的php.ini-production 复制到 /usr/local/php5.3.29/etc 下 1cp /tmp/php-5.3.29/php.ini-production php.ini php-fpm的配置文件不存在，这边参考 lnmp里面的配置 1cp /usr/local/php/etc/php-fpm.conf php-fpm.conf 然后修改对应的启动参数 这样子 启动的 php-fpm 的配置就和之前的一致了 加入服务自启 在 /etc/init.d 里面增加 php-fpm5.3.29 参考 lnmp 里面的 12345678cd /etc/init.dcp php-fpm php-fpm5.3.29vi php-fpm5.3.29# 修改下面的内容# prefix=/usr/local/php ==&gt; prefix=/usr/local/php5.3.29# 加入到自启服务chkconfig --add php-fpm5.3.29 接下来 reboot 上图可看到，三种php-fpm已经启动 接下来就是nginx 里面fastcgi 自行选择了 参考文章Linux上编译安装PHPphp编译安装configure 一些参数详解编译php ./configure命令enable和with有什么区别核心配置选项列表 Linux(CentOS)下设置php-fpm开机自动启动 在编译安装的过程中，查看这些文献，算是稍微了解了一下php编译安装,之前都是用集成工具（公司里面运维处理了）。安装后，对于Linux的服务自启也优老一点概念。所以前人说，一定要源码编译一次，真的是真真有道理的。 另一个比较好的学习脚本就是 lnmp 里面的 sh 脚本。之后学习Shell，可以参考这里面的~~~。有时间可以好好看看 lnmp的思路。 END闲话扯一下，在处理这个过程中，其实顺带看了许多，包括nginx对动静态的处理，php-fpm的配置，这里就不介绍了，自己也没做相关的梳理。以上内容都是在虚拟机里面完成的，速度比自己的云主机上快很多，毕竟云主机的配置太低。真心觉得自己当初把开发环境迁移到虚拟机上的选择是正确的，还有很多想法都可以一一的去完成。 感谢观看，拜拜~~","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}]},{"title":"Nginx访问VMware挂载文件","slug":"linux/vmware-php-gz","date":"2019-05-07T15:53:00.000Z","updated":"2019-05-09T13:30:10.214Z","comments":true,"path":"2019/05/07/linux/vmware-php-gz/","link":"","permalink":"http://yoursite.com/2019/05/07/linux/vmware-php-gz/","excerpt":"","text":"问题LNMP安装之后，Nginx无法访问共享的目录 方法一 ROOT一般来说无法的问题，基本上都是权限的问题，Nginx访问 403 Forbidden 查看Nginx的权限 1ps aux | grep 'nginx' 修改Nginx的权限为 root 启动 12345vi /usr/local/nginx/conf/nginx.conf# 修改user www www 为 user root rootnginx -s reload 这样Nginx就能访问挂载下的目录文件了，至少 静态文件 ok的 没错，仅仅是静态文件，php文件是无法访问的 查看php-fpm的权限 1ps aux | grep 'php-fpm' 修改 php-fpm权限为root 启动 12345vi /usr/local/php/etc/php-fpm.conf# 以下修改为 root# user = root# group = root 1234service php-fpm restartGracefully shutting down php-fpm . doneStarting php-fpm [08-May-2019 09:13:48] ERROR: [pool www] please specify user and group other than root 没错，shut down 是成功了，但是启动不了，无法用root启动的。当然非要启动也有办法 123php-fpm -R# more php-fpm --help 这样子就成功用root启动了 之后访问 php文件，你会发现 可以被解析了 当然这个方法不推荐，安全性太低了，虽然开发环境无上大雅，但是生产环境是不能允许的 思考：难道就没有更好的解决方案了？ 方法二 (推荐)答案当然是有的！！ 既然无法越权访问，那么思路就是允许其他组访问 Nginx 和 PHP 默认都是www组，那么就让挂载的文件的权限为 www 123# 查询组IDid www# uid=1001(www) gid=1001(www) 组=1001(www) 123如果每次重启之后想让系统自动挂载 #vi /etc/fstab:在最后添加一行：.host:/VM_Shared /mnt/hgfs fuse.vmhgfs-fuse allow_other 0 0 1.host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other,uid=你的uid,gid=你的gid 此方法替换之前开机自动挂载的方法 参考文章：【同问题】Using a mounted NTFS share with nginx【解决】vmware挂载了windows的共享目录给nginx使用的默认用户组的问题 END爬坑的过程，还算不错，挺好的","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"vmware","slug":"vmware","permalink":"http://yoursite.com/tags/vmware/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}]},{"title":"VMware + Centos7 安装与配置","slug":"linux/vmware-centos7","date":"2019-05-06T05:39:00.000Z","updated":"2019-05-09T13:26:42.635Z","comments":true,"path":"2019/05/06/linux/vmware-centos7/","link":"","permalink":"http://yoursite.com/2019/05/06/linux/vmware-centos7/","excerpt":"","text":"题记生产环境一直是Linux的，但本地的开发环境是Windows的，虽然已经尽可能和线上同步了（如 php的版本一致），但是毕竟底层不同还是会存在一定上的差别。一方面也是为了让自己更加熟悉使用Linux的系统，另一方面也是为了之后使用一些新的特性，如swoole。至于VMware,大学的时候玩过，后来没怎么使用，最近回顾玩一下，并记录一下心得。 环境Win10 专业版 + VMware 15 + CentOS 7 VMware 安装VMware的安装就不说明了，密钥网上也一大堆 CentOS 7镜像文件可从官网上下载，下面是我使用的链接 下载链接 安装的教程，可参考网上的教程，挺多的，12的教程居多，不过基本上一样的。 ps：不建议安装图形界面，好像默认也不是图形界面，这点挺好的。不过如果非要安装，这个要自行查找了，应该很容易就能找到解决方法的。 配置好的，到这一步，默认认为都已经安装好系统了，接下来就介绍一下，个人在配置过程中遇到的问题以及要解决的问题。 Q1:网络配置问题Q2:CV大法配置,不能复制粘贴，这个怎么能愉快的敲敲敲呢Q3:共享文件设置，这个很重要，毕竟虚拟机的硬盘不能分配过大，否则本机的空间的不行。另外，修改同一个文件，岂不美哉？！ 网络配置刚配置完系统后，你会发现是并不能上网的，有人可能会说，虚拟机不能上网没什么关系啊。NO,其实很不方便，最直观的例子，yum这个好东西你就不能用了，安装软件岂不是很痛苦。所以网络的问题要第一解决。 网上一些教程选择桥接模式，这边是默认的NAT模式，在我看来，NAT模式更加适合我对虚拟机的使用，内网模式。 这边采用静态配置，系统默认的是DHCP,动态的，至于静态的理由，很简单，重启的时候不用改IP,毕竟这台虚拟机之后是要作为开发环境使用的，总不能每次重启，我代码里面还要修改IP吧。 网络的基本属性可在【编辑】-&gt;【虚拟网络编辑器】 中查看 NAT设置中的 网关IP 在静态配置中会使用到，一般来说不用修改。 打开网卡编辑文件 1vi /etc/sysconfig/network-scripts/ifcfg-ens33 下面是要修改的内容，不存在添加，存在则修改 1234567BOOTPROTO=staticONBOOT=yesIPADDR=192.168.147.128NETMASK=255.255.255.0GATEWAY=192.168.147.2DNS1=114.114.114.114DNS2=4.4.4.4 ONBOOT 启动时候加载网卡，上网的关键设置 DNS 这个根据自己的网络所在位置来决定，必须配置，否则无法解析域名，限制比较多 修改完后 执行以下命令重启网卡 1service network restart 就能愉快的ping了 至于本机上虚拟网卡配置，其实不配也不影响使用，因为我上面分配的是100多的，基本上撞的概率很低，如果要配置的，ipv4的静态配置这里就不介绍了，相信能自行解决的，网关注意一致就行了。 CV大法解决需要安装 vmware-tools，这个安装比较坑，目测需要理解挂载的机制。不过我安装好后，不知道怎么CV。 这边我的解决方法是 xshell5 链接到 这台虚拟机上，利用xshell 来操作，感觉还不赖。 偷鸡界的王者~~~ 共享文件设置这个弄了挺久的，一方面是vm-tools的安装，另一方面好像是挂载的问题。下面会介绍这两个方面。 安装tools 在安装系统的时候，注意一下下方，其实会有提示的，这边没有选择安装，而是稍后安装。立即安装应该也只是下载而已，没多大必要。进入系统后，点击 【虚拟机】-&gt;【重新安装VMwareTools】,注意下方的弹框，点击 【帮助】，不要找网上那些花里胡哨的东西，点击后跳转的是官方的安装介绍，里面的内容很详细，比网上的一些靠谱多了。 戳我直接看 按照官方的一步步下来，看到 enjoy 为止 不过当然不会那么顺理，再执行 vmware-install.pl 的时候可能会有问题的。 注意 perl, gcc 有无安装，反正我的centos 没有安装的 1234# 这就用到上面的网络了，不设置无法使用yum -y install perlyum -y install gcc 完成上面步，基本上可以一路 Enter 下来，不过到 Kernel 的时候，你可以选择 no 然后再一路 Enter 就 ok 了，不过也可以更新 kernel，这样子就能一路 Enter。 完成后 可以看到 Enjoy 字样 mnt 目录下会有hfgs的目录 1vmware-hgfsclient 执行这个命令可以看到你共享的文件夹 共享的设置 不过仅执行上一步，还是无法看到共享的文件的 参考：戳这里 这篇文章正解 核心内容 mount -t vmhgfs .host:/py_script /mnt/hgfs 如果出现：Error: cannot mount filesystem: No such device这样的报错 (基本上100%报错，请使用下面的命令) vmhgfs-fuse .host:/WorkSpaces /mnt/hgfs 多文件挂载可以建一个空的文件 vmhgfs-fuse .host:/test /mnt/test host:/test 就是你设置共享时候的名称 /mnt/test 就是系统中的目录位置 开机启动上述的挂载每次重启后，就要重新执行一遍，所以开机自启挺好的 12# 共享的文件全部挂载echo \"vmhgfs-fuse .host:/ /mnt/hgfs\" &gt;&gt; /etc/rc.d/rc.local 注意一下执行的权限 1chmod +x /etc/rc.d/rc.local 之前没有执行的权限，又走了一点弯路 ps: 新增 （2019年5月8号） 在下文《Nginx访问VMware挂载文件》中，会替换上面的开机自动挂载的方法。同时对应一些文件权限的问题也会讲解到。 END至此基础的系统算是搭建好了，接下就是各个环境的安装，费了不少功夫，不过也算有所得，记录一些，可以防坑。 玩下来的感觉，Linux的入坑之路正式开始。","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"},{"name":"vmware","slug":"vmware","permalink":"http://yoursite.com/tags/vmware/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}]},{"title":"重学PHP之属性和方法的重载","slug":"php/overloading-property-method","date":"2019-04-30T02:56:00.000Z","updated":"2019-04-30T05:24:35.222Z","comments":true,"path":"2019/04/30/php/overloading-property-method/","link":"","permalink":"http://yoursite.com/2019/04/30/php/overloading-property-method/","excerpt":"","text":"题记之前也了解过这一块的知识，但是没系统看过。这次回顾，系统的记录一下这个使用，加深自己的印象。 ps:在回顾《PHP5 权威指南》中，真的发现自己在写程序中缺少很多设计以及很多特性的使用。 以下内容主要是对书中的内容进行记录。 属性和方法的重载PHP 允许通过实现特殊的代理方法对属性的访问和方法的调用进行重载，这些代理方法将在相关的属性或者方法不存在时调用。 可以实现下面方法的原型 function __get($property) function __set($property, $value) function __call($method, $args) __get 传递属性的名字，并返回属性的值 __set 传递属性的名字和新的值 __call 传递方法的名字和一个数字索引的数组，数组包含传递的参数，第一个参数的索引是0 get &amp;&amp; set1234567891011121314151617181920212223242526272829class Test&#123; private $arr = array( 'x' =&gt; null, 'y' =&gt; null ); function __get($property)&#123; if(array_key_exists($property, $this-&gt;arr))&#123; return $this-&gt;arr[$property]; &#125;else&#123; print \"Error: Can not Read a property other than x and y\\n\"; &#125; &#125; function __set($property, $value)&#123; if(array_key_exists($property, $this-&gt;arr))&#123; return $this-&gt;arr[$property] = $value; &#125;else&#123; print \"Error: Can not Write a property other than x and y\\n\"; &#125; &#125;&#125;$test = new Test();$test-&gt;x = 1;print $test-&gt;x.\"\\n\";$test-&gt;n = 3;print $test-&gt;n; 1231Error: Can not Read a property other than x and yError: Can not Write a property other than x and y 利用上面的方式，很多赋值就不必用那种又臭又长的传参或者统一放在一个看不着的数组里面传入。看着更优雅一点。 __call这个使用，就我个人而言，实际可能使用的频率不会向上面的两个那么频繁，框架设计另说了。 123456789101112131415161718192021222324252627class HelloWorld&#123; function display($count)&#123; for($i = 0; $i &lt; $count; $i++)&#123; print \"Hello, World \\n\"; &#125; return $count; &#125;&#125;class HelloWorldDelegator&#123; private $obj; function __construct() &#123; $this-&gt;obj = new HelloWorld(); &#125; function __call($name, $arguments) &#123; // 书中方法; // return call_user_func_array(array($this-&gt;obj, $name), $arguments); return $this-&gt;obj-&gt;$name($arguments[0]); &#125;&#125;$obj = new HelloWorldDelegator();print $obj-&gt;display(3); $arguments 是数组，定义中有说明 __call 传递方法的名字和一个数字索引的数组，数组包含传递的参数，第一个参数的索引是0 1print $obj-&gt;display(3,4); 然后打印一下，可以发现 12$argumentsarray(2) &#123; [0]=&gt; int(3) [1]=&gt; int(4) &#125; call_user_func_array 调用回调函数，并把一个数组参数作为回调函数的参数 More 这个方法也是很好用的,下面列举具体的使用说明。 12345678910111213141516function foobar($arg, $arg2) &#123; echo __FUNCTION__, \" got $arg and $arg2\\n\";&#125;class foo &#123; function bar($arg, $arg2) &#123; echo __METHOD__, \" got $arg and $arg2\\n\"; &#125;&#125;// Call the foobar() function with 2 argumentscall_user_func_array(\"foobar\", array(\"one\", \"two\"));// Call the $foo-&gt;bar() method with 2 arguments$foo = new foo;call_user_func_array(array($foo, \"bar\"), array(\"three\", \"four\")); 思考回顾中针对自己也做了一些思考，我目前负责的项目中，许多独立的功能是可以被重写的。 并不是说功能不能用，而是可读性和扩展性上无法和有设计过的相比，这算是是实践后的一种反思吧。 不过实际中的业务场景并不会像demo中的那么简单，好的设计应该是基于对业务准确的理解上的。","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}],"keywords":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}]},{"title":"PHP之Eval函数","slug":"php/eval","date":"2019-04-29T07:54:00.000Z","updated":"2019-04-29T08:26:49.680Z","comments":true,"path":"2019/04/29/php/eval/","link":"","permalink":"http://yoursite.com/2019/04/29/php/eval/","excerpt":"","text":"题记回顾翻阅《PHP5 权威指南》这本书的时候，偶尔间看到了 Eval 这个函数。回想起曾经疑惑 W3C 网站或 Leetcode 这些网站上是怎么执行用户提交的代码的，看到它，瞬间开朗了。激动的做了一下小实验。 eval()(PHP 4, PHP 5, PHP 7) eval — 把字符串作为PHP代码执行 更多详细官方资料，戳我 123$s = '$var = 222;';eval($s);print($var); 1234567$func =&lt;&lt;&lt;FUNCfunction test()&#123; echo \"test eval function\"; &#125;FUNC;eval($func);test(); 注意 eval的参数，必须是合法的 PHP 代码。 （ps:在测试中，字符串赋值之类的，老是会忘记封号结尾。) END此函数确实存在如官方所说的风险在，因为允许执行用户输入的代码，所以平时不建议使用。 不过有一类的场景，就是学习类的网站，检验代码执行结果之类的，如 W3C ,Leetcode,ACM之类等等。 用此函数能快速简易的实现代码执行的核心的功能。","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}],"keywords":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}]},{"title":"sourceTree 添加 ssh key 方法","slug":"git/sourcetree","date":"2019-04-29T06:25:00.000Z","updated":"2019-04-29T06:29:36.563Z","comments":true,"path":"2019/04/29/git/sourcetree/","link":"","permalink":"http://yoursite.com/2019/04/29/git/sourcetree/","excerpt":"","text":"题记使用Git应该也有一段时间了，但对于SourceTree的配置一直不甚了解，恰好遇到SourceTree配置SSH,公钥这些早就配置过了的。转载别人的文章，记录一下。 【转载】https://blog.csdn.net/tengdazhang770960436/article/details/54171911","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}]},{"title":"好用的SimpleXml","slug":"php/simplexml","date":"2019-04-28T06:56:00.000Z","updated":"2019-04-28T07:00:43.168Z","comments":true,"path":"2019/04/28/php/simplexml/","link":"","permalink":"http://yoursite.com/2019/04/28/php/simplexml/","excerpt":"","text":"题记此文只是做简单的记录，php中对xml的操作，偶然间看到的，目前实际应用场景中，json格式居多，xml很少，几乎没用过这篇文章就当是一个概要。之后如果用到，可作为提示之用。 话不多说，直接撸码。 12345678910111213141516$xml = \"&lt;clients&gt;&lt;client&gt; &lt;name&gt;Boy&lt;/name&gt; &lt;account&gt;1234567&lt;/account&gt;&lt;/client&gt;&lt;client&gt; &lt;name&gt;Girl&lt;/name&gt; &lt;account&gt;2345678&lt;/account&gt;&lt;/client&gt;&lt;/clients&gt;\";$list = simplexml_load_string($xml);// $file = 'a.xml';// $file_list = simplexml_load_file($file);foreach ($list as $v)&#123; echo $v-&gt;name .' account is ' . $v-&gt;account.'&lt;br/&gt;';&#125; simplexml_load_string 字面意思，加载string xml simplexml_load_file 字面意思，从文件中加载 加载完成后就能像对象那样操作了。 END笔记文章，水文一篇","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}],"keywords":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}]},{"title":"TP 3.2 升级到 PHP 7","slug":"php/tp3-to-php7","date":"2019-04-02T08:35:00.000Z","updated":"2019-04-29T02:59:20.905Z","comments":true,"path":"2019/04/02/php/tp3-to-php7/","link":"","permalink":"http://yoursite.com/2019/04/02/php/tp3-to-php7/","excerpt":"","text":"题记TP 3.2 是 PHP 5的版本框架，升级到7的过程中，算是比较平滑，因为之前的代码还算规范，但是也有些坑，这里简单的记录一下，之后应该也没有人会用3.2的框架了吧。 坑一：Memcache Session失效若session采用memcache，则会遇到此问题。解决方案： 修改 ThinkPHP\\Library\\Think\\Session\\Driver\\memcache.class.php 12345678910111213141516 /** * 读取Session * @access public * @param string $sessID */public function read($sessID) &#123; $this-&gt;_connect(); $rs = $this-&gt;handle-&gt;get($this-&gt;sessionName.$sessID); $this-&gt;_close(); // 原来 // return $rs return (string)$rs;&#125; END目前刚开始公司的项目的升级，这篇文章会不定时更新的。","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}],"keywords":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}]},{"title":"Yapi + Nginx","slug":"nginx/nginx-yapi","date":"2019-03-26T08:48:00.000Z","updated":"2019-04-29T03:01:16.698Z","comments":true,"path":"2019/03/26/nginx/nginx-yapi/","link":"","permalink":"http://yoursite.com/2019/03/26/nginx/nginx-yapi/","excerpt":"","text":"题记这篇文章不算从零搭建，只是记录一下其中的坑。 环境客户端：Chrome服务器：Linux + Nginx 正文Yapi的内网搭建，照官网上来的即可，99.99%不会出问题（0.01%看人品）。 在公司搭建的过程中，运维搭建好，配好域名，在使用过程中发现，在添加，删除，编辑，会出现奇怪的问题，要么JS报错导致页面错误，要么页面没变化，刚开始真的没头绪。 这时候，万能的 F12 来了。 看到一个很奇怪的现象 from disk cache 字面意思读本地缓存，这就神奇了，这之前没遇到过，点开发现 竟然存在10分钟的缓存， 比较了我本地搭建的，IP+端口没有缓存的，本地的操作就都是正常的。 至此大胆猜测了一下，就是这缓存导致的，而且假设有缓存的情况，上述的奇怪的现象都能解释得通了。 于是让运维去检查一下nginx里面是不是设置了缓存到期时间。 果然，然后，就好了。 结束语其实在之前，运维搭过一次，但是之前在忙别的事，竟然让运维重新搭建，主要自己本地的是好的，然后也是自己不熟nodejs，有点惶恐。 这次问题的解决，发现问题可以慢慢仔细分析，总能解决的。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}]},{"title":"Nginx下Vue的部署","slug":"nginx/nginx-vue","date":"2019-03-18T09:16:00.000Z","updated":"2019-04-29T03:01:16.727Z","comments":true,"path":"2019/03/18/nginx/nginx-vue/","link":"","permalink":"http://yoursite.com/2019/03/18/nginx/nginx-vue/","excerpt":"","text":"题记此部署是前后端完全分离，前端域名和后端非同域名的情况，同域名的话，Nginx的配置自行修改，不过在我看来配分个三级域名处理起来更方便直接。 环境Linux + Nginx + Git Niginx的配置Nginx的配置比较简单，也就是入口处的静态资源的加载1234567891011server &#123; listen 80; #根目录的位置 root /home/www/adminwww/iview-admin-dist; #绑定域名 server_name *.test.com; location / &#123; index index.html index.htm; &#125; &#125; Git安装git,就是为了拉取代码用，同步更新服务器上的代码，因为每次打包的HASH的关系，文件都是不一样的，因此不能简单的覆盖，如果当版本更新次数多了的话，传统的上传会导致服务器上无效的文件会增大，使用Git就能避免此问题。 本地打包上传到 Master,服务器上 pull 一下，over!! Git的安装就不在这里描述，我是用最简单的安装方式1yum install git 其他安装方式，自行搜索吧 温馨提示：记得 git pull免密哦 END其实还有更省事的两个方案方案一：Jenkins的持续集成（腾讯云上的那个没搞懂，就放弃了，代码在coding上，本来想这么操作，会爽歪歪的）。方案二：写个shell脚本，后台写个方法，点击触发git pull事件，这样子就可以不用登服务器了。 本着负责任的态度，截至2019年3月18号，我没实现。以后实现了，再加吧。 拜拜，谢谢观看。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}]},{"title":"Windows下Redis服务运行","slug":"redis/windows-redis-server","date":"2019-03-14T02:52:00.000Z","updated":"2019-04-29T03:00:14.695Z","comments":true,"path":"2019/03/14/redis/windows-redis-server/","link":"","permalink":"http://yoursite.com/2019/03/14/redis/windows-redis-server/","excerpt":"","text":"Redis安装安装并没什么可讲的，我是下载了绿色版的，因此没有自动安装成为windows服务，据说msi版是自动安装成为windows服务的。具体可参考 点我，点我，点我 为什么选择服务窗口，窗口，窗口，一不小心关掉，Redis就挂了。未安装为服务的时候，Redis服务端的窗口要一直开着，不小心关了，Redis服务也就终止了，所以安装成服务最省心了。强迫症患者必备。 安装服务在进入redis的安装目录后，执行以下的命令 安装服务redis-server –service-install redis.windows.conf –loglevel verbose 卸载服务redis-server –service-uninstall 启动服务redis-server –service-start 停止服务redis-server –service-stop 命名服务可以启动三个独立的redis服务：redis-server –service-install –service-name redisService1 –port 10001redis-server –service-start –service-name redisService1 redis-server –service-install –service-name redisService2 –port 10002redis-server –service-start –service-name redisService2 redis-server –service-install –service-name redisService3 –port 10003redis-server –service-start –service-name redisService3 原文CSDNEND愉快的在本地开发吧，不用担心窗口被关闭掉，导致Redis没法用","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}]},{"title":"爬楼梯","slug":"algorithm/climbing-stairs","date":"2019-02-22T09:43:00.000Z","updated":"2019-04-27T09:49:24.163Z","comments":true,"path":"2019/02/22/algorithm/climbing-stairs/","link":"","permalink":"http://yoursite.com/2019/02/22/algorithm/climbing-stairs/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/climbing-stairs/ 题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 分析其核心算法是下一个数是前面两个数之和，前面几个阶梯我们可以很轻松就能知道，2阶2步，3阶3步，那4阶就是5步。 解答 12345678910111213function climbStairs($n) &#123; if($n &lt; 4)&#123; return $n; &#125; $num = array(1,2,3); $sum = 0; for($i = 3; $i &lt; $n; $i++)&#123; $num[$i] = $num[$i-1] + $num[$i-2]; $sum = $num[$i]; unset($num[$i-2]); &#125; return $sum;&#125; end空间换时间方法，据说还有一种数学方法，公式不知道，算了。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"相同的树","slug":"algorithm/same-tree","date":"2019-02-22T08:28:00.000Z","updated":"2019-04-29T03:01:16.712Z","comments":true,"path":"2019/02/22/algorithm/same-tree/","link":"","permalink":"http://yoursite.com/2019/02/22/algorithm/same-tree/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/same-tree/submissions/ 温馨提示 这篇属于水文，水文，水文！！！ 题目给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例1234567输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]输出: true 1234567输入: 1 1 / \\ 2 2 [1,2], [1,null,2]输出: false 1234567输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]输出: false 分析这个应该是证明 PHP是世界上最好的语言的其中一道算法题了，这道题就当是娱乐吧，底层原理没去深究，只能感叹PHP的数组是真强 解答 123function isSameTree($p, $q) &#123; return $p == $q; &#125; end划水片。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"合并两个有序数组","slug":"algorithm/merge-sorted-array","date":"2019-02-18T10:25:00.000Z","updated":"2019-04-29T03:01:16.691Z","comments":true,"path":"2019/02/18/algorithm/merge-sorted-array/","link":"","permalink":"http://yoursite.com/2019/02/18/algorithm/merge-sorted-array/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/merge-sorted-array/ 题目给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 分析此题应该主要考察数组合并以及排序，不过使用 PHP ,并未去实现底层，直接用自带的方法了，就当是一个记录吧 解答 1234567function merge(&amp;$nums1, $m, $nums2, $n) &#123; $nums1 = array_slice($nums1, 0, $m); $nums2 = array_slice($nums2, 0, $n); $nums1 = array_merge($nums1 , $nums2); sort($nums1); return $nums1;&#125; end主要用到 array_slice , array_merge 以及最后的排序 sort ,偷了一把鸡。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"有效的括号","slug":"algorithm/valid-parentheses","date":"2019-02-18T06:56:00.000Z","updated":"2019-04-29T03:01:16.705Z","comments":true,"path":"2019/02/18/algorithm/valid-parentheses/","link":"","permalink":"http://yoursite.com/2019/02/18/algorithm/valid-parentheses/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/valid-parentheses/ 题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意: 空字符串可被认为是有效字符串。 示例 输入: “()”输出: true 输入: “()[]{}”输出: true 输入: “(]”输出: false 输入: “([)]”输出: false 输入: “{[]}”输出: true 分析要想成立，必须要是偶数，另外 2n+1 位是第 n 位 的闭合位置 解答 12345678910111213141516171819202122232425262728function isValid($s) &#123; $string_arr = array( '(' =&gt; -1, ')' =&gt; 1, '&#123;' =&gt; -2, '&#125;' =&gt; 2, '[' =&gt; -3, ']' =&gt; 3, '$' =&gt; 0 ); $length = strlen($s); if($length % 2 != 0) return false; for($i = 0; $i &lt; $length; $i++)&#123; if($s[$i] == '$') continue; $first = $string_arr[$s[$i]]; $is_true = false; for($j = $i + 1; $j &lt; $length; $j = $j + 2)&#123; if($first + $string_arr[$s[$j]] == 0)&#123; $is_true = true; $s = substr_replace($s,\"$\",$j,1); $s = substr_replace($s,\"$\",0,1); break; &#125; &#125; if(!$is_true) return false; &#125; return true;&#125; end执行效率貌似不高，暂未想到更优解法。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"最长公共前缀","slug":"algorithm/longest-common-prefix","date":"2019-02-16T08:55:00.000Z","updated":"2019-04-29T03:01:16.720Z","comments":true,"path":"2019/02/16/algorithm/longest-common-prefix/","link":"","permalink":"http://yoursite.com/2019/02/16/algorithm/longest-common-prefix/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/longest-common-prefix/ 题目编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 输入: [“flower”,”flow”,”flight”]输出: “fl” 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 分析取出数组的第一个值，然后循环字符串，循环数组，单个判断，一旦不符合，退出循环，返回数据 解答 12345678910111213function longestCommonPrefix($strs) &#123; $first_arr = $strs[0]; $str = ''; for($i = 0; $i &lt; strlen($first_arr); $i++)&#123; for($j = 1; $j &lt; count($strs); $j++)&#123; if($strs[$j][$i] != $first_arr[$i])&#123; break 2; &#125; &#125; $str .= $first_arr[$i]; &#125; return $str;&#125; 另外官方上有很多其他的算法，上面应该是官方的第一种方案。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"罗马数字转整数","slug":"algorithm/roman-to-number","date":"2019-02-16T08:07:00.000Z","updated":"2019-04-29T03:01:16.751Z","comments":true,"path":"2019/02/16/algorithm/roman-to-number/","link":"","permalink":"http://yoursite.com/2019/02/16/algorithm/roman-to-number/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/roman-to-integer/ 题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 输入: “III”输出: 3 输入: “IV”输出: 4 输入: “IX”输出: 9 输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3. 输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 分析罗马数字的核心规则是 如果前一位比后一位小，则一起处理，否则单独处理 解答 1234567891011121314151617181920212223242526function romanToInt($s) &#123; // 定义罗马数字 $_roman = array( 'I' =&gt; 1, 'V' =&gt; 5, 'X' =&gt; 10, 'L' =&gt; 50, 'C' =&gt; 100, 'D' =&gt; 500, 'M' =&gt; 1000 ); $length = strlen($s) - 1; $num = 0; while ($length &gt;= 0)&#123; // 如果前一位比后一位小，则一起处理,否则单个处理 if($length &gt; 0 &amp;&amp; $_roman[$s[$length-1]] &lt; $_roman[$s[$length]])&#123; $num += ($_roman[$s[$length]] - $_roman[$s[$length-1]]); $length = $length - 1; &#125;else&#123; $num += $_roman[$s[$length]]; &#125; $length = $length - 1; &#125; return $num;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"回文数","slug":"algorithm/palindrome-number","date":"2019-02-16T07:28:00.000Z","updated":"2019-04-29T03:01:16.758Z","comments":true,"path":"2019/02/16/algorithm/palindrome-number/","link":"","permalink":"http://yoursite.com/2019/02/16/algorithm/palindrome-number/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/palindrome-number/ 题目判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例1 输入: 121输出: true 示例2 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 分析从例子中，我们可以看出负数肯定不是回文数，给位数肯定是回文数，只需要判断大于10的数即可，利用字符串来处理是比较简单的。 解答 123456789101112131415function isPalindrome($x) &#123; if($x &lt; 0) return false; if($x &lt; 10) return true; $string_x = $x . ''; $length = strlen($string_x); $result = true; for($i = 0; $i &lt; $length; $i++)&#123; if($i &gt;= $length - $i - 1) break; if($string_x[$i] != $string_x[$length - $i - 1])&#123; $result = false; break; &#125; &#125; return $result;&#125; 后来搜了一下PHP的语法，有个 strrev函数 ，用这个方法一句话解决123function isPalindrome($x) &#123; return strrev($x) == $x ? true : false;&#125; 这两个方法在Leetcode提交的上面执行的时间和消耗都差不多 ##进阶版 你能不将整数转为字符串来解决这个问题吗？ 分析这种情况，只能用数学的方法来解决，整除+取余，取余后逆计算，排除中位数的情况，判断一半长度的数据，和官方说的反转一半数字的思路一致 123456789101112function isPalindrome($x)&#123; // 排除负数和尾部为0的数据,0 除外，这些肯定不是回文数 if($x &lt; 0 || ($x % 10 == 0 &amp;&amp; $x != 0)) return false; $pre = 0; while($x &gt; $pre) &#123; $pop = $x % 10; $x = intval($x/10); $pre = $pre * 10 + $pop; &#125; // 只需要判断相等的情况 return $x == $pre || $x == intval($pre/10);&#125; 返回说明当数字长度为奇数时，我们可以通过 pre/10 去除处于中位的数字。例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 $x = 12，$pre = 123，由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。(上述文字措辞来自官方，变量修改了一下)","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"整数反转","slug":"algorithm/reverse-int","date":"2019-02-16T03:57:00.000Z","updated":"2019-04-29T03:01:16.737Z","comments":true,"path":"2019/02/16/algorithm/reverse-int/","link":"","permalink":"http://yoursite.com/2019/02/16/algorithm/reverse-int/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/reverse-integer/ 题目给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例1 输入: 123输出: 321 示例2 输入: -123输出: -321 示例3 输入: 120输出: 21 注意假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解答 123456789101112131415161718192021function reverse($x) &#123; $a = $x &gt;= 0 ? 1 : -1; $string_num = '' . abs($x); $string_new = ''; for($i = strlen($string_num) - 1; $i &gt;= 0; $i--)&#123; $string_new .= $string_num[$i]; &#125; // 64位机子和32位，php int值不同，故返回时候多加了个最大值判断 $new = (int)$string_new; $max = pow(2,31); if($a == -1)&#123; if($string_new == $max) &#123; $end = $max * -1; &#125;else&#123; $end = $new != $string_new || $new &gt; $max ? 0 : $new * -1; &#125; &#125;else&#123; $end = $new != $string_new || $new &gt; $max ? 0 : $new; &#125; return $end; &#125; 官方解法方法：弹出和推入数字 &amp; 溢出前进行检查思路 我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。 算法 反转整数的方法可以与反转字符串进行类比。 我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 \\text{rev}rev 的后面。最后，\\text{rev}rev 将与 xx 相反。 要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。 //pop operation:pop = x % 10;x /= 10;//push operation:temp = rev * 10 + pop;rev = temp; 但是，这种方法很危险，因为当 \\text{temp} = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 时会导致溢出。 幸运的是，事先检查这个语句是否会导致溢出很容易。 为了便于解释，我们假设rev 是正数。 当rev 为负时可以应用类似的逻辑。 1234567891011121314function reverse($x) &#123; $rev = 0; $max = pow(2, 31); $min = -$max; $max = $max - 1; while ($x != 0) &#123; $pop = $x % 10; $x = intval($x/10); if ($rev &gt; $max / 10 || ($rev == $max / 10 &amp;&amp; $pop &gt; 7)) return 0; if ($rev &lt; $min / 10 || ($rev == $min / 10 &amp;&amp; $pop &lt; -8)) return 0; $rev = $rev * 10 + $pop; &#125; return $rev; &#125; 心得 在提交的过程中，校验时候才发了 64位机子和32位，php int值不同，故返回时候多加了个最大值判断算是学到了一点，应该是php版本里面的设置导致的，这点还没深入去了解，另外发现，领扣的校验，这个效率真的不太准，多提交几次，时间还都不一样，发点小牢骚。 纯数学的思路，有时候其实可以省很多代码。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"两数之和","slug":"algorithm/two-sum","date":"2019-02-16T01:56:00.000Z","updated":"2019-04-29T03:01:16.744Z","comments":true,"path":"2019/02/16/algorithm/two-sum/","link":"","permalink":"http://yoursite.com/2019/02/16/algorithm/two-sum/","excerpt":"","text":"本片是算法学习的第一篇，就多唠嗑几句。 （沉默思考………………….） 算了，还是入正题好了 题目来源：https://leetcode-cn.com/problems/two-sum/submissions/ 也是朋友安利的一个做题网站【力扣】，个人觉得，闲的时候可以做做题目，保持饥饿感(^__^) 其实里面也有官方的题解的，自己写完之后，然后再看一下官方的解答思路，对于小白来说，肯定会有收获的（大神就不要理会了）。 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 123456789101112131415class Solution &#123; function twoSum($nums, $target) &#123; $length = count($nums); $result = array(); for($i = 0; $i &lt; $length; $i++)&#123; for($j = $i + 1; $j &lt; $length; $j++)&#123; if($nums[$i] + $nums[$j] == $target) &#123; $result = array($i, $j); break 2; &#125; &#125; &#125; return $result; &#125;&#125; 上面的解答是官方的第一种方法，暴力法，其他的方法，就是空间换时间呗 不过官方说的HASH解法，这个用PHP暂时没实现。 未完待续………….","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]}]}