{"meta":{"title":"熊猫园","subtitle":"博客","description":"闲时杂谈","author":"wikipine","url":"http://yoursite.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-04-25T12:34:50.458Z","updated":"2019-04-25T12:34:50.444Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":"&lt;!DOCTYPE html&gt; 404"},{"title":"关于","date":"2019-04-25T13:04:44.000Z","updated":"2019-04-25T13:28:27.069Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"首先感谢各位看客老爷们百忙之中能看到这个页面 我本人93射手男，其他个人信息就不公布了 欢迎技术交流，或愿意交朋友的点击 社交 里面的QQ (暗号：github) 博客本博客不定时更新 主要记录个人的学习心得，以及工作中遇到的值得记录的问题，内容非研究级别，但尽量实用型。 有何不对的地方欢迎指正。"}],"posts":[{"title":"sourceTree 添加 ssh key 方法","slug":"git/sourcetree","date":"2019-04-29T06:25:00.000Z","updated":"2019-04-29T06:29:36.563Z","comments":true,"path":"2019/04/29/git/sourcetree/","link":"","permalink":"http://yoursite.com/2019/04/29/git/sourcetree/","excerpt":"","text":"题记使用Git应该也有一段时间了，但对于SourceTree的配置一直不甚了解，恰好遇到SourceTree配置SSH,公钥这些早就配置过了的。转载别人的文章，记录一下。 【转载】https://blog.csdn.net/tengdazhang770960436/article/details/54171911","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}]},{"title":"好用的SimpleXml","slug":"php/simplexml","date":"2019-04-28T06:56:00.000Z","updated":"2019-04-28T07:00:43.168Z","comments":true,"path":"2019/04/28/php/simplexml/","link":"","permalink":"http://yoursite.com/2019/04/28/php/simplexml/","excerpt":"","text":"题记此文只是做简单的记录，php中对xml的操作，偶然间看到的，目前实际应用场景中，json格式居多，xml很少，几乎没用过这篇文章就当是一个概要。之后如果用到，可作为提示之用。 话不多说，直接撸码。 12345678910111213141516$xml = \"&lt;clients&gt;&lt;client&gt; &lt;name&gt;Boy&lt;/name&gt; &lt;account&gt;1234567&lt;/account&gt;&lt;/client&gt;&lt;client&gt; &lt;name&gt;Girl&lt;/name&gt; &lt;account&gt;2345678&lt;/account&gt;&lt;/client&gt;&lt;/clients&gt;\";$list = simplexml_load_string($xml);// $file = 'a.xml';// $file_list = simplexml_load_file($file);foreach ($list as $v)&#123; echo $v-&gt;name .' account is ' . $v-&gt;account.'&lt;br/&gt;';&#125; simplexml_load_string 字面意思，加载string xml simplexml_load_file 字面意思，从文件中加载 加载完成后就能像对象那样操作了。 END笔记文章，水文一篇","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}],"keywords":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}]},{"title":"TP 3.2 升级到 PHP 7","slug":"php/tp3-to-php7","date":"2019-04-02T08:35:00.000Z","updated":"2019-04-29T02:59:20.905Z","comments":true,"path":"2019/04/02/php/tp3-to-php7/","link":"","permalink":"http://yoursite.com/2019/04/02/php/tp3-to-php7/","excerpt":"","text":"题记TP 3.2 是 PHP 5的版本框架，升级到7的过程中，算是比较平滑，因为之前的代码还算规范，但是也有些坑，这里简单的记录一下，之后应该也没有人会用3.2的框架了吧。 坑一：Memcache Session失效若session采用memcache，则会遇到此问题。解决方案： 修改 ThinkPHP\\Library\\Think\\Session\\Driver\\memcache.class.php 12345678910111213141516 /** * 读取Session * @access public * @param string $sessID */public function read($sessID) &#123; $this-&gt;_connect(); $rs = $this-&gt;handle-&gt;get($this-&gt;sessionName.$sessID); $this-&gt;_close(); // 原来 // return $rs return (string)$rs;&#125; END目前刚开始公司的项目的升级，这篇文章会不定时更新的。","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}],"keywords":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}]},{"title":"Yapi + Nginx","slug":"nginx/nginx-yapi","date":"2019-03-26T08:48:00.000Z","updated":"2019-04-29T03:01:16.698Z","comments":true,"path":"2019/03/26/nginx/nginx-yapi/","link":"","permalink":"http://yoursite.com/2019/03/26/nginx/nginx-yapi/","excerpt":"","text":"题记这篇文章不算从零搭建，只是记录一下其中的坑。 环境客户端：Chrome服务器：Linux + Nginx 正文Yapi的内网搭建，照官网上来的即可，99.99%不会出问题（0.01%看人品）。 在公司搭建的过程中，运维搭建好，配好域名，在使用过程中发现，在添加，删除，编辑，会出现奇怪的问题，要么JS报错导致页面错误，要么页面没变化，刚开始真的没头绪。 这时候，万能的 F12 来了。 看到一个很奇怪的现象 from disk cache 字面意思读本地缓存，这就神奇了，这之前没遇到过，点开发现 竟然存在10分钟的缓存， 比较了我本地搭建的，IP+端口没有缓存的，本地的操作就都是正常的。 至此大胆猜测了一下，就是这缓存导致的，而且假设有缓存的情况，上述的奇怪的现象都能解释得通了。 于是让运维去检查一下nginx里面是不是设置了缓存到期时间。 果然，然后，就好了。 结束语其实在之前，运维搭过一次，但是之前在忙别的事，竟然让运维重新搭建，主要自己本地的是好的，然后也是自己不熟nodejs，有点惶恐。 这次问题的解决，发现问题可以慢慢仔细分析，总能解决的。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"},{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}]},{"title":"Nginx下Vue的部署","slug":"nginx/nginx-vue","date":"2019-03-18T09:16:00.000Z","updated":"2019-04-29T03:01:16.727Z","comments":true,"path":"2019/03/18/nginx/nginx-vue/","link":"","permalink":"http://yoursite.com/2019/03/18/nginx/nginx-vue/","excerpt":"","text":"题记此部署是前后端完全分离，前端域名和后端非同域名的情况，同域名的话，Nginx的配置自行修改，不过在我看来配分个三级域名处理起来更方便直接。 环境Linux + Nginx + Git Niginx的配置Nginx的配置比较简单，也就是入口处的静态资源的加载1234567891011server &#123; listen 80; #根目录的位置 root /home/www/adminwww/iview-admin-dist; #绑定域名 server_name *.test.com; location / &#123; index index.html index.htm; &#125; &#125; Git安装git,就是为了拉取代码用，同步更新服务器上的代码，因为每次打包的HASH的关系，文件都是不一样的，因此不能简单的覆盖，如果当版本更新次数多了的话，传统的上传会导致服务器上无效的文件会增大，使用Git就能避免此问题。 本地打包上传到 Master,服务器上 pull 一下，over!! Git的安装就不在这里描述，我是用最简单的安装方式1yum install git 其他安装方式，自行搜索吧 温馨提示：记得 git pull免密哦 END其实还有更省事的两个方案方案一：Jenkins的持续集成（腾讯云上的那个没搞懂，就放弃了，代码在coding上，本来想这么操作，会爽歪歪的）。方案二：写个shell脚本，后台写个方法，点击触发git pull事件，这样子就可以不用登服务器了。 本着负责任的态度，截至2019年3月18号，我没实现。以后实现了，再加吧。 拜拜，谢谢观看。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}]},{"title":"Windows下Redis服务运行","slug":"redis/windows-redis-server","date":"2019-03-14T02:52:00.000Z","updated":"2019-04-29T03:00:14.695Z","comments":true,"path":"2019/03/14/redis/windows-redis-server/","link":"","permalink":"http://yoursite.com/2019/03/14/redis/windows-redis-server/","excerpt":"","text":"Redis安装安装并没什么可讲的，我是下载了绿色版的，因此没有自动安装成为windows服务，据说msi版是自动安装成为windows服务的。具体可参考 点我，点我，点我 为什么选择服务窗口，窗口，窗口，一不小心关掉，Redis就挂了。未安装为服务的时候，Redis服务端的窗口要一直开着，不小心关了，Redis服务也就终止了，所以安装成服务最省心了。强迫症患者必备。 安装服务在进入redis的安装目录后，执行以下的命令 安装服务redis-server –service-install redis.windows.conf –loglevel verbose 卸载服务redis-server –service-uninstall 启动服务redis-server –service-start 停止服务redis-server –service-stop 命名服务可以启动三个独立的redis服务：redis-server –service-install –service-name redisService1 –port 10001redis-server –service-start –service-name redisService1 redis-server –service-install –service-name redisService2 –port 10002redis-server –service-start –service-name redisService2 redis-server –service-install –service-name redisService3 –port 10003redis-server –service-start –service-name redisService3 原文CSDNEND愉快的在本地开发吧，不用担心窗口被关闭掉，导致Redis没法用","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}]},{"title":"爬楼梯","slug":"algorithm/climbing-stairs","date":"2019-02-22T09:43:00.000Z","updated":"2019-04-27T09:49:24.163Z","comments":true,"path":"2019/02/22/algorithm/climbing-stairs/","link":"","permalink":"http://yoursite.com/2019/02/22/algorithm/climbing-stairs/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/climbing-stairs/ 题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 分析其核心算法是下一个数是前面两个数之和，前面几个阶梯我们可以很轻松就能知道，2阶2步，3阶3步，那4阶就是5步。 解答 12345678910111213function climbStairs($n) &#123; if($n &lt; 4)&#123; return $n; &#125; $num = array(1,2,3); $sum = 0; for($i = 3; $i &lt; $n; $i++)&#123; $num[$i] = $num[$i-1] + $num[$i-2]; $sum = $num[$i]; unset($num[$i-2]); &#125; return $sum;&#125; end空间换时间方法，据说还有一种数学方法，公式不知道，算了。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"相同的树","slug":"algorithm/same-tree","date":"2019-02-22T08:28:00.000Z","updated":"2019-04-29T03:01:16.712Z","comments":true,"path":"2019/02/22/algorithm/same-tree/","link":"","permalink":"http://yoursite.com/2019/02/22/algorithm/same-tree/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/same-tree/submissions/ 温馨提示 这篇属于水文，水文，水文！！！ 题目给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例1234567输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]输出: true 1234567输入: 1 1 / \\ 2 2 [1,2], [1,null,2]输出: false 1234567输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]输出: false 分析这个应该是证明 PHP是世界上最好的语言的其中一道算法题了，这道题就当是娱乐吧，底层原理没去深究，只能感叹PHP的数组是真强 解答 123function isSameTree($p, $q) &#123; return $p == $q; &#125; end划水片。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"合并两个有序数组","slug":"algorithm/merge-sorted-array","date":"2019-02-18T10:25:00.000Z","updated":"2019-04-29T03:01:16.691Z","comments":true,"path":"2019/02/18/algorithm/merge-sorted-array/","link":"","permalink":"http://yoursite.com/2019/02/18/algorithm/merge-sorted-array/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/merge-sorted-array/ 题目给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 分析此题应该主要考察数组合并以及排序，不过使用 PHP ,并未去实现底层，直接用自带的方法了，就当是一个记录吧 解答 1234567function merge(&amp;$nums1, $m, $nums2, $n) &#123; $nums1 = array_slice($nums1, 0, $m); $nums2 = array_slice($nums2, 0, $n); $nums1 = array_merge($nums1 , $nums2); sort($nums1); return $nums1;&#125; end主要用到 array_slice , array_merge 以及最后的排序 sort ,偷了一把鸡。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"有效的括号","slug":"algorithm/valid-parentheses","date":"2019-02-18T06:56:00.000Z","updated":"2019-04-29T03:01:16.705Z","comments":true,"path":"2019/02/18/algorithm/valid-parentheses/","link":"","permalink":"http://yoursite.com/2019/02/18/algorithm/valid-parentheses/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/valid-parentheses/ 题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意: 空字符串可被认为是有效字符串。 示例 输入: “()”输出: true 输入: “()[]{}”输出: true 输入: “(]”输出: false 输入: “([)]”输出: false 输入: “{[]}”输出: true 分析要想成立，必须要是偶数，另外 2n+1 位是第 n 位 的闭合位置 解答 12345678910111213141516171819202122232425262728function isValid($s) &#123; $string_arr = array( '(' =&gt; -1, ')' =&gt; 1, '&#123;' =&gt; -2, '&#125;' =&gt; 2, '[' =&gt; -3, ']' =&gt; 3, '$' =&gt; 0 ); $length = strlen($s); if($length % 2 != 0) return false; for($i = 0; $i &lt; $length; $i++)&#123; if($s[$i] == '$') continue; $first = $string_arr[$s[$i]]; $is_true = false; for($j = $i + 1; $j &lt; $length; $j = $j + 2)&#123; if($first + $string_arr[$s[$j]] == 0)&#123; $is_true = true; $s = substr_replace($s,\"$\",$j,1); $s = substr_replace($s,\"$\",0,1); break; &#125; &#125; if(!$is_true) return false; &#125; return true;&#125; end执行效率貌似不高，暂未想到更优解法。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"最长公共前缀","slug":"algorithm/longest-common-prefix","date":"2019-02-16T08:55:00.000Z","updated":"2019-04-29T03:01:16.720Z","comments":true,"path":"2019/02/16/algorithm/longest-common-prefix/","link":"","permalink":"http://yoursite.com/2019/02/16/algorithm/longest-common-prefix/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/longest-common-prefix/ 题目编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 输入: [“flower”,”flow”,”flight”]输出: “fl” 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 分析取出数组的第一个值，然后循环字符串，循环数组，单个判断，一旦不符合，退出循环，返回数据 解答 12345678910111213function longestCommonPrefix($strs) &#123; $first_arr = $strs[0]; $str = ''; for($i = 0; $i &lt; strlen($first_arr); $i++)&#123; for($j = 1; $j &lt; count($strs); $j++)&#123; if($strs[$j][$i] != $first_arr[$i])&#123; break 2; &#125; &#125; $str .= $first_arr[$i]; &#125; return $str;&#125; 另外官方上有很多其他的算法，上面应该是官方的第一种方案。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"罗马数字转整数","slug":"algorithm/roman-to-number","date":"2019-02-16T08:07:00.000Z","updated":"2019-04-29T03:01:16.751Z","comments":true,"path":"2019/02/16/algorithm/roman-to-number/","link":"","permalink":"http://yoursite.com/2019/02/16/algorithm/roman-to-number/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/roman-to-integer/ 题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 输入: “III”输出: 3 输入: “IV”输出: 4 输入: “IX”输出: 9 输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3. 输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 分析罗马数字的核心规则是 如果前一位比后一位小，则一起处理，否则单独处理 解答 1234567891011121314151617181920212223242526function romanToInt($s) &#123; // 定义罗马数字 $_roman = array( 'I' =&gt; 1, 'V' =&gt; 5, 'X' =&gt; 10, 'L' =&gt; 50, 'C' =&gt; 100, 'D' =&gt; 500, 'M' =&gt; 1000 ); $length = strlen($s) - 1; $num = 0; while ($length &gt;= 0)&#123; // 如果前一位比后一位小，则一起处理,否则单个处理 if($length &gt; 0 &amp;&amp; $_roman[$s[$length-1]] &lt; $_roman[$s[$length]])&#123; $num += ($_roman[$s[$length]] - $_roman[$s[$length-1]]); $length = $length - 1; &#125;else&#123; $num += $_roman[$s[$length]]; &#125; $length = $length - 1; &#125; return $num;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"回文数","slug":"algorithm/palindrome-number","date":"2019-02-16T07:28:00.000Z","updated":"2019-04-29T03:01:16.758Z","comments":true,"path":"2019/02/16/algorithm/palindrome-number/","link":"","permalink":"http://yoursite.com/2019/02/16/algorithm/palindrome-number/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/palindrome-number/ 题目判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例1 输入: 121输出: true 示例2 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 分析从例子中，我们可以看出负数肯定不是回文数，给位数肯定是回文数，只需要判断大于10的数即可，利用字符串来处理是比较简单的。 解答 123456789101112131415function isPalindrome($x) &#123; if($x &lt; 0) return false; if($x &lt; 10) return true; $string_x = $x . ''; $length = strlen($string_x); $result = true; for($i = 0; $i &lt; $length; $i++)&#123; if($i &gt;= $length - $i - 1) break; if($string_x[$i] != $string_x[$length - $i - 1])&#123; $result = false; break; &#125; &#125; return $result;&#125; 后来搜了一下PHP的语法，有个 strrev函数 ，用这个方法一句话解决123function isPalindrome($x) &#123; return strrev($x) == $x ? true : false;&#125; 这两个方法在Leetcode提交的上面执行的时间和消耗都差不多 ##进阶版 你能不将整数转为字符串来解决这个问题吗？ 分析这种情况，只能用数学的方法来解决，整除+取余，取余后逆计算，排除中位数的情况，判断一半长度的数据，和官方说的反转一半数字的思路一致 123456789101112function isPalindrome($x)&#123; // 排除负数和尾部为0的数据,0 除外，这些肯定不是回文数 if($x &lt; 0 || ($x % 10 == 0 &amp;&amp; $x != 0)) return false; $pre = 0; while($x &gt; $pre) &#123; $pop = $x % 10; $x = intval($x/10); $pre = $pre * 10 + $pop; &#125; // 只需要判断相等的情况 return $x == $pre || $x == intval($pre/10);&#125; 返回说明当数字长度为奇数时，我们可以通过 pre/10 去除处于中位的数字。例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 $x = 12，$pre = 123，由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。(上述文字措辞来自官方，变量修改了一下)","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"整数反转","slug":"algorithm/reverse-int","date":"2019-02-16T03:57:00.000Z","updated":"2019-04-29T03:01:16.737Z","comments":true,"path":"2019/02/16/algorithm/reverse-int/","link":"","permalink":"http://yoursite.com/2019/02/16/algorithm/reverse-int/","excerpt":"","text":"题目来源：https://leetcode-cn.com/problems/reverse-integer/ 题目给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例1 输入: 123输出: 321 示例2 输入: -123输出: -321 示例3 输入: 120输出: 21 注意假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解答 123456789101112131415161718192021function reverse($x) &#123; $a = $x &gt;= 0 ? 1 : -1; $string_num = '' . abs($x); $string_new = ''; for($i = strlen($string_num) - 1; $i &gt;= 0; $i--)&#123; $string_new .= $string_num[$i]; &#125; // 64位机子和32位，php int值不同，故返回时候多加了个最大值判断 $new = (int)$string_new; $max = pow(2,31); if($a == -1)&#123; if($string_new == $max) &#123; $end = $max * -1; &#125;else&#123; $end = $new != $string_new || $new &gt; $max ? 0 : $new * -1; &#125; &#125;else&#123; $end = $new != $string_new || $new &gt; $max ? 0 : $new; &#125; return $end; &#125; 官方解法方法：弹出和推入数字 &amp; 溢出前进行检查思路 我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。 算法 反转整数的方法可以与反转字符串进行类比。 我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 \\text{rev}rev 的后面。最后，\\text{rev}rev 将与 xx 相反。 要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。 //pop operation:pop = x % 10;x /= 10;//push operation:temp = rev * 10 + pop;rev = temp; 但是，这种方法很危险，因为当 \\text{temp} = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 时会导致溢出。 幸运的是，事先检查这个语句是否会导致溢出很容易。 为了便于解释，我们假设rev 是正数。 当rev 为负时可以应用类似的逻辑。 1234567891011121314function reverse($x) &#123; $rev = 0; $max = pow(2, 31); $min = -$max; $max = $max - 1; while ($x != 0) &#123; $pop = $x % 10; $x = intval($x/10); if ($rev &gt; $max / 10 || ($rev == $max / 10 &amp;&amp; $pop &gt; 7)) return 0; if ($rev &lt; $min / 10 || ($rev == $min / 10 &amp;&amp; $pop &lt; -8)) return 0; $rev = $rev * 10 + $pop; &#125; return $rev; &#125; 心得 在提交的过程中，校验时候才发了 64位机子和32位，php int值不同，故返回时候多加了个最大值判断算是学到了一点，应该是php版本里面的设置导致的，这点还没深入去了解，另外发现，领扣的校验，这个效率真的不太准，多提交几次，时间还都不一样，发点小牢骚。 纯数学的思路，有时候其实可以省很多代码。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]},{"title":"两数之和","slug":"algorithm/two-sum","date":"2019-02-16T01:56:00.000Z","updated":"2019-04-29T03:01:16.744Z","comments":true,"path":"2019/02/16/algorithm/two-sum/","link":"","permalink":"http://yoursite.com/2019/02/16/algorithm/two-sum/","excerpt":"","text":"本片是算法学习的第一篇，就多唠嗑几句。 （沉默思考………………….） 算了，还是入正题好了 题目来源：https://leetcode-cn.com/problems/two-sum/submissions/ 也是朋友安利的一个做题网站【力扣】，个人觉得，闲的时候可以做做题目，保持饥饿感(^__^) 其实里面也有官方的题解的，自己写完之后，然后再看一下官方的解答思路，对于小白来说，肯定会有收获的（大神就不要理会了）。 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 123456789101112131415class Solution &#123; function twoSum($nums, $target) &#123; $length = count($nums); $result = array(); for($i = 0; $i &lt; $length; $i++)&#123; for($j = $i + 1; $j &lt; $length; $j++)&#123; if($nums[$i] + $nums[$j] == $target) &#123; $result = array($i, $j); break 2; &#125; &#125; &#125; return $result; &#125;&#125; 上面的解答是官方的第一种方法，暴力法，其他的方法，就是空间换时间呗 不过官方说的HASH解法，这个用PHP暂时没实现。 未完待续………….","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]}]}